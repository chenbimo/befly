# TypeScript 最佳实践

在 Befly 项目中使用 TypeScript 的最佳实践指南。

## 项目结构

### 推荐的文件组织

```
project/
├── types/              # 类型定义目录
│   ├── index.ts        # 导出所有类型
│   ├── models.ts       # 数据模型
│   ├── api.ts          # API 相关类型
│   └── common.ts       # 通用类型
├── apis/               # API 接口
│   ├── user/
│   │   ├── login.ts
│   │   ├── register.ts
│   │   └── profile.ts
│   └── product/
│       ├── list.ts
│       └── detail.ts
├── utils/              # 工具函数
│   ├── format.ts
│   ├── validate.ts
│   └── helpers.ts
├── plugins/            # 插件
│   ├── cache.ts
│   └── logger.ts
├── tables/             # 表定义
│   └── user.json
└── main.ts             # 入口文件
```

## 类型定义原则

### 1. 优先使用 interface 而非 type

对于对象结构，优先使用 `interface`：

```typescript
// ✅ 推荐
interface User {
    id: number;
    username: string;
    email: string;
}

// ⚠️ 仅在需要联合类型时使用 type
type UserRole = 'admin' | 'user' | 'guest';
```

**原因**：

-   interface 更适合描述对象结构
-   interface 支持声明合并
-   interface 有更好的错误提示

### 2. 为数据模型定义完整类型

```typescript
// types/models.ts
export interface User {
    id: number;
    username: string;
    email: string;
    role: UserRole;
    createdAt: number;
    updatedAt: number;
    deletedAt: number | null;
    state: number;
}

export type UserRole = 'admin' | 'user' | 'guest';

export interface Product {
    id: number;
    name: string;
    price: number;
    stock: number;
    categoryId: number;
    tags: string[];
    createdAt: number;
    updatedAt: number;
}

export interface Order {
    id: number;
    userId: number;
    productId: number;
    quantity: number;
    totalPrice: number;
    status: OrderStatus;
    createdAt: number;
}

export type OrderStatus = 'pending' | 'paid' | 'shipped' | 'completed' | 'cancelled';
```

### 3. 使用 Partial、Required、Pick、Omit 等工具类型

```typescript
// 创建用户时不需要 id 和时间戳
type CreateUserDto = Omit<User, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt' | 'state'>;

// 更新用户时所有字段都是可选的
type UpdateUserDto = Partial<CreateUserDto>;

// 仅包含公开信息
type PublicUser = Pick<User, 'id' | 'username' | 'role'>;

// 必填用户名和邮箱
type RequiredUser = Required<Pick<User, 'username' | 'email'>>;
```

## API 开发最佳实践

### 1. 为每个接口定义独立的类型

```typescript
// apis/user/list.ts
import { Api, Yes, No } from 'befly';
import type { BeflyContext } from 'befly/types';
import type { User } from '../../types/models';
import type { ListResult } from 'befly/utils';

// 请求参数类型
interface GetUsersRequest {
    page?: number;
    limit?: number;
    role?: string;
    keyword?: string;
}

// 响应数据类型
type GetUsersResponse = ListResult<PublicUser>;

type PublicUser = Pick<User, 'id' | 'username' | 'email' | 'role' | 'createdAt'>;

export default Api.POST(
    '获取用户列表',
    ['admin'],
    {
        page: '页码⚡number⚡1⚡9999⚡1⚡0⚡null',
        limit: '每页数量⚡number⚡1⚡100⚡10⚡0⚡null',
        role: '角色⚡string⚡0⚡20⚡null⚡0⚡^(admin|user|guest)$',
        keyword: '关键词⚡string⚡0⚡50⚡null⚡0⚡null'
    },
    [],
    async (befly: BeflyContext, ctx: any) => {
        try {
            const params = ctx.body as GetUsersRequest;

            const where: any = {};
            if (params.role) where.role = params.role;
            if (params.keyword) where.username = { $like: `%${params.keyword}%` };

            const result = await befly.db.getList<User>({
                table: 'user',
                fields: ['id', 'username', 'email', 'role', 'created_at'],
                where,
                page: params.page || 1,
                limit: params.limit || 10,
                orderBy: 'created_at DESC'
            });

            return Yes<GetUsersResponse>('查询成功', result);
        } catch (error: any) {
            befly.logger.error({ msg: '查询用户失败', error: error.message });
            return No('查询失败');
        }
    }
);
```

### 2. 使用类型守卫确保数据安全

```typescript
// utils/typeGuards.ts
export function isUser(obj: any): obj is User {
    return typeof obj === 'object' && obj !== null && typeof obj.id === 'number' && typeof obj.username === 'string' && typeof obj.email === 'string';
}

export function isValidEmail(email: any): email is string {
    return typeof email === 'string' && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

// 使用示例
import { isUser, isValidEmail } from '../../utils/typeGuards';

const data = ctx.body;
if (!isUser(data)) {
    return No('无效的用户数据');
}

if (!isValidEmail(data.email)) {
    return No('无效的邮箱格式');
}

// 此时 TypeScript 知道 data 是 User 类型
const user: User = data;
```

### 3. 避免使用 any，使用 unknown

```typescript
// ❌ 不推荐
async function processData(data: any) {
    return data.name.toUpperCase(); // 可能运行时错误
}

// ✅ 推荐
async function processData(data: unknown) {
    // 先类型检查
    if (typeof data === 'object' && data !== null && 'name' in data) {
        const obj = data as { name: string };
        return obj.name.toUpperCase();
    }
    throw new Error('Invalid data');
}
```

## 数据库操作最佳实践

### 1. 使用泛型指定查询结果类型

```typescript
import type { User, Product } from '../types/models';

// ✅ 推荐：明确指定返回类型
const user = await befly.db.getDetail<User>({
    table: 'user',
    where: { id: 1 }
});

if (user) {
    // TypeScript 知道 user 的类型
    console.log(user.username); // ✅ 有智能提示
}

// ✅ 列表查询
const result = await befly.db.getList<Product>({
    table: 'product',
    page: 1,
    limit: 10
});

result.list.forEach((product) => {
    console.log(product.name); // ✅ 有智能提示
});

// ❌ 不推荐：不指定类型
const user2 = await befly.db.getDetail({
    table: 'user',
    where: { id: 1 }
});
// user2 的类型是 any，没有智能提示
```

### 2. 使用类型断言处理复杂查询

```typescript
// 联合查询返回的复杂结构
interface UserWithOrderCount extends User {
    orderCount: number;
}

const users = await befly.db.query<UserWithOrderCount>(
    `SELECT u.*, COUNT(o.id) as order_count
     FROM user u
     LEFT JOIN \`order\` o ON u.id = o.user_id
     GROUP BY u.id`
);

users.forEach((user) => {
    console.log(`${user.username}: ${user.orderCount} orders`);
});
```

### 3. 事务中的类型安全

```typescript
interface CreateOrderResult {
    orderId: number;
    userId: number;
    totalPrice: number;
}

const result = await befly.db.trans<CreateOrderResult>(async (trans) => {
    // 扣减库存
    await trans.updData({
        table: 'product',
        data: { stock: newStock },
        where: { id: productId }
    });

    // 创建订单
    const orderId = await trans.insData({
        table: 'order',
        data: orderData
    });

    // 返回结果（类型安全）
    return {
        orderId,
        userId: orderData.userId,
        totalPrice: orderData.totalPrice
    };
});

// result 的类型是 CreateOrderResult
console.log(`订单 ${result.orderId} 创建成功`);
```

## Redis 操作最佳实践

### 1. 为缓存数据定义类型

```typescript
// types/cache.ts
export interface CachedUser {
    id: number;
    username: string;
    role: string;
}

export interface CachedProduct {
    id: number;
    name: string;
    price: number;
    stock: number;
}

// 使用示例
import type { CachedUser } from '../types/cache';

// 设置缓存
await befly.redis.setObject<CachedUser>(`user:${userId}`, { id: userId, username: 'test', role: 'user' }, 3600);

// 获取缓存
const cached = await befly.redis.getObject<CachedUser>(`user:${userId}`);
if (cached) {
    console.log(cached.username); // ✅ 有智能提示
}
```

### 2. 使用常量管理缓存键

```typescript
// utils/cacheKeys.ts
export const CacheKeys = {
    user: (id: number) => `user:${id}`,
    userList: (page: number, limit: number) => `user:list:${page}:${limit}`,
    product: (id: number) => `product:${id}`,
    productList: (categoryId: number) => `product:list:${categoryId}`
} as const;

// 使用示例
import { CacheKeys } from '../utils/cacheKeys';

const cached = await befly.redis.getObject<CachedUser>(CacheKeys.user(userId));
```

## 错误处理最佳实践

### 1. 定义错误类型

```typescript
// types/errors.ts
export class AppError extends Error {
    constructor(public code: string, message: string, public details?: any) {
        super(message);
        this.name = 'AppError';
    }
}

export class ValidationError extends AppError {
    constructor(message: string, details?: any) {
        super('VALIDATION_ERROR', message, details);
        this.name = 'ValidationError';
    }
}

export class DatabaseError extends AppError {
    constructor(message: string, details?: any) {
        super('DATABASE_ERROR', message, details);
        this.name = 'DatabaseError';
    }
}

export class AuthError extends AppError {
    constructor(message: string, details?: any) {
        super('AUTH_ERROR', message, details);
        this.name = 'AuthError';
    }
}
```

### 2. 统一错误处理

```typescript
import { AppError, ValidationError, DatabaseError, AuthError } from '../types/errors';

export default Api.POST(
    '创建用户',
    ['admin'],
    {
        /* fields */
    },
    [],
    async (befly, ctx) => {
        try {
            // 业务逻辑
            const data = ctx.body;

            // 手动验证
            if (!data.username) {
                throw new ValidationError('用户名不能为空');
            }

            // 数据库操作
            try {
                const userId = await befly.db.insData({
                    table: 'user',
                    data
                });
                return Yes('创建成功', { userId });
            } catch (err) {
                throw new DatabaseError('创建用户失败', { original: err });
            }
        } catch (error: unknown) {
            // 类型安全的错误处理
            if (error instanceof ValidationError) {
                befly.logger.warn({ msg: error.message, details: error.details });
                return No(error.message);
            }

            if (error instanceof DatabaseError) {
                befly.logger.error({ msg: error.message, details: error.details });
                return No('服务器错误');
            }

            if (error instanceof AppError) {
                befly.logger.error({ msg: error.message, code: error.code });
                return No(error.message);
            }

            // 未知错误
            const err = error as Error;
            befly.logger.error({ msg: '未知错误', error: err.message });
            return No('服务器错误');
        }
    }
);
```

## 插件开发最佳实践

### 1. 为插件定义类型

```typescript
// plugins/cache.ts
import type { BeflyContext } from 'befly/types';

interface CachePlugin {
    get<T = any>(key: string): Promise<T | null>;
    set<T = any>(key: string, value: T, ttl?: number): Promise<void>;
    del(key: string): Promise<void>;
    clear(): Promise<void>;
}

export default {
    name: 'cache',

    async onInit(befly: BeflyContext): Promise<CachePlugin> {
        return {
            async get<T = any>(key: string): Promise<T | null> {
                return await befly.redis.getObject<T>(key);
            },

            async set<T = any>(key: string, value: T, ttl?: number): Promise<void> {
                await befly.redis.setObject<T>(key, value, ttl);
            },

            async del(key: string): Promise<void> {
                await befly.redis.delObject(key);
            },

            async clear(): Promise<void> {
                // 实现清除所有缓存的逻辑
            }
        };
    }
};

// 扩展 BeflyContext 类型
declare module 'befly/types' {
    interface BeflyContext {
        cache: CachePlugin;
    }
}
```

### 2. 使用模块增强

```typescript
// types/befly.d.ts
import type { CachePlugin } from '../plugins/cache';
import type { EmailPlugin } from '../plugins/email';

declare module 'befly/types' {
    interface BeflyContext {
        cache: CachePlugin;
        email: EmailPlugin;
    }
}

// 现在在任何地方使用 befly 都有这些插件的类型提示
```

## 工具函数最佳实践

### 1. 使用函数重载

```typescript
// utils/format.ts

// 格式化日期
export function formatDate(timestamp: number): string;
export function formatDate(timestamp: number, format: 'date'): string;
export function formatDate(timestamp: number, format: 'time'): string;
export function formatDate(timestamp: number, format: 'datetime'): string;
export function formatDate(timestamp: number, format?: string): string {
    const date = new Date(timestamp);

    switch (format) {
        case 'date':
            return date.toISOString().split('T')[0];
        case 'time':
            return date.toISOString().split('T')[1].split('.')[0];
        case 'datetime':
        default:
            return date.toISOString().replace('T', ' ').split('.')[0];
    }
}

// 使用时有智能提示
const date = formatDate(Date.now()); // string
const dateOnly = formatDate(Date.now(), 'date'); // string
```

### 2. 使用泛型约束

```typescript
// utils/helpers.ts

// 安全地访问对象属性
export function getProperty<T extends object, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}

// 使用示例
interface User {
    id: number;
    username: string;
}

const user: User = { id: 1, username: 'test' };
const username = getProperty(user, 'username'); // 类型是 string
// const invalid = getProperty(user, 'invalid'); // ❌ 编译错误
```

## 配置管理最佳实践

### 1. 定义配置类型

```typescript
// types/config.ts
export interface AppConfig {
    server: {
        port: number;
        host: string;
    };
    database: {
        type: 'mysql' | 'postgresql' | 'sqlite';
        host: string;
        port: number;
        name: string;
        user: string;
        password: string;
    };
    redis: {
        host: string;
        port: number;
        password: string;
        db: number;
    };
    jwt: {
        secret: string;
        expiresIn: string;
    };
}

// config/index.ts
import type { AppConfig } from '../types/config';

export const config: AppConfig = {
    server: {
        port: parseInt(process.env.PORT || '3000'),
        host: process.env.HOST || '0.0.0.0'
    },
    database: {
        type: (process.env.DB_TYPE as any) || 'mysql',
        host: process.env.DB_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT || '3306'),
        name: process.env.DB_NAME || 'befly',
        user: process.env.DB_USER || 'root',
        password: process.env.DB_PASSWORD || ''
    },
    redis: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
        password: process.env.REDIS_PASSWORD || '',
        db: parseInt(process.env.REDIS_DB || '0')
    },
    jwt: {
        secret: process.env.JWT_SECRET || 'your-secret-key',
        expiresIn: process.env.JWT_EXPIRES_IN || '7d'
    }
};
```

## 测试最佳实践

### 1. 为测试定义类型

```typescript
// tests/api.test.ts
import { describe, test, expect } from 'bun:test';
import type { User } from '../types/models';

describe('User API', () => {
    test('should create user', async () => {
        const newUser = {
            username: 'test',
            email: 'test@example.com',
            password: 'password123'
        };

        const response = await fetch('http://localhost:3000/api/user/create', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(newUser)
        });

        const json = await response.json();
        expect(json.code).toBe(0);

        // 类型断言
        const userData = json.data as { userId: number };
        expect(typeof userData.userId).toBe('number');
    });
});
```

## 性能优化建议

### 1. 使用类型推断减少显式声明

```typescript
// ❌ 不必要的类型声明
const name: string = 'John';
const age: number = 30;

// ✅ 让 TypeScript 自动推断
const name = 'John'; // 推断为 string
const age = 30; // 推断为 number
```

### 2. 避免过度使用泛型

```typescript
// ❌ 过度复杂
function process<T, U extends keyof T, V extends T[U]>(data: T, key: U): V {
    return data[key];
}

// ✅ 简单明了
function getValue<T extends object, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}
```

## 总结

遵循这些最佳实践，你将能够：

1. **类型安全**：在编译时捕获大部分错误
2. **代码提示**：获得完整的 IDE 智能提示
3. **易于维护**：类型作为文档，清晰表达意图
4. **重构友好**：安全地进行大规模代码重构
5. **团队协作**：统一的类型定义减少沟通成本

继续探索 TypeScript，你会发现它带来的远不止这些好处！
