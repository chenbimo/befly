/**
 * 数据库表结构同步脚本 - TypeScript 版本
 * 支持 sqlite / mysql / postgresql
 * 注意：MySQL 提供更完整的在线 ALTER 能力；SQLite/PG 的修改能力有差异，部分操作将跳过或分解。
 */

import path from 'node:path';
import { Env } from '../config/env.js';
import { Logger } from '../utils/logger.js';
import { createSqlClient, toSnakeTableName, isType, parseRule } from '../utils/index.js';
import { __dirtables, getProjectDir } from '../system.js';
import { scanAddons, getAddonDir, hasAddonDir } from '../utils/addonHelper.js';
import checkTable from '../checks/table.js';

import type { SQL } from 'bun';
import type { ColumnInfo, IndexInfo, FieldChange, IndexAction, TablePlan, GlobalCount } from '../types/database.js';

// ==================== 常量定义 ====================

/**
 * 数据库版本要求
 */
const DB_VERSION_REQUIREMENTS = {
    MYSQL_MIN_MAJOR: 8,
    POSTGRES_MIN_MAJOR: 17,
    SQLITE_MIN_VERSION: '3.50.0',
    SQLITE_MIN_VERSION_NUM: 35000 // 3 * 10000 + 50 * 100
} as const;

/**
 * 系统字段定义（所有表都包含的固定字段）
 */
const SYSTEM_FIELDS = {
    ID: { name: 'id', comment: '主键ID' },
    CREATED_AT: { name: 'created_at', comment: '创建时间' },
    UPDATED_AT: { name: 'updated_at', comment: '更新时间' },
    DELETED_AT: { name: 'deleted_at', comment: '删除时间' },
    STATE: { name: 'state', comment: '状态字段' }
} as const;

/**
 * 需要创建索引的系统字段
 */
const SYSTEM_INDEX_FIELDS = ['created_at', 'updated_at', 'state'] as const;

/**
 * 字段变更类型的中文标签映射
 */
const CHANGE_TYPE_LABELS = {
    length: '长度',
    datatype: '类型',
    comment: '注释',
    default: '默认值'
} as const;

// ==================== 全局变量 ====================

// 顶部管理数据库客户端（按需求使用 Bun SQL 模板，不使用 exec 辅助）
let sql: SQL | null = null;

// 方言与类型映射
const DB = (Env.DB_TYPE || 'mysql').toLowerCase();
const IS_MYSQL = DB === 'mysql';
const IS_PG = DB === 'postgresql' || DB === 'postgres';
const IS_SQLITE = DB === 'sqlite'; // 命令行参数
const ARGV = Array.isArray(process.argv) ? process.argv : [];
const IS_PLAN = ARGV.includes('--plan');

// 字段类型映射（按方言）
const typeMapping = {
    number: IS_SQLITE ? 'INTEGER' : 'BIGINT',
    string: IS_SQLITE ? 'TEXT' : IS_PG ? 'character varying' : 'VARCHAR',
    text: IS_MYSQL ? 'MEDIUMTEXT' : 'TEXT',
    array: IS_SQLITE ? 'TEXT' : IS_PG ? 'character varying' : 'VARCHAR'
};

// 全局统计
const globalCount: GlobalCount = {
    // 表级
    processedTables: 0,
    createdTables: 0,
    modifiedTables: 0,
    // 字段与索引级
    addFields: 0,
    typeChanges: 0,
    maxChanges: 0, // 映射为长度变化
    minChanges: 0, // 最小值不参与 DDL，比对保留为0
    defaultChanges: 0,
    nameChanges: 0, // 字段显示名（注释）变更
    indexCreate: 0,
    indexDrop: 0
};

// ==================== 辅助函数 ====================

/**
 * 根据数据库类型引用标识符（表名、列名）
 * MySQL 使用反引号 `，PostgreSQL 和 SQLite 使用双引号 "
 *
 * @param name - 标识符名称
 * @returns 带引号的标识符
 */
const quoteIdentifier = (name: string): string => {
    return IS_MYSQL ? `\`${name}\`` : `"${name}"`;
};

/**
 * 记录字段变更日志（统一格式）
 *
 * @param tableName - 表名
 * @param fieldKey - 字段键名
 * @param changeType - 变更类型
 * @param currentValue - 当前值
 * @param newValue - 新值
 */
const logFieldChange = (tableName: string, fieldKey: string, changeType: string, currentValue: any, newValue: any): void => {
    const label = CHANGE_TYPE_LABELS[changeType as keyof typeof CHANGE_TYPE_LABELS] || changeType;
    Logger.info(`[字段变更] ${tableName}.${fieldKey} ${label}: ${currentValue ?? 'NULL'} -> ${newValue ?? 'NULL'}`);
};

/**
 * 性能统计对象
 */
const perfStats = {
    startTime: 0,
    phases: new Map<string, number>()
};

/**
 * 标记阶段开始时间
 *
 * @param phaseName - 阶段名称
 */
const markPhase = (phaseName: string): void => {
    perfStats.phases.set(phaseName, Date.now());
};

/**
 * 计算阶段耗时
 *
 * @param phaseName - 阶段名称
 * @returns 耗时（毫秒）
 */
const getPhaseTime = (phaseName: string): number => {
    const startTime = perfStats.phases.get(phaseName);
    return startTime ? Date.now() - startTime : 0;
};

// PG 兼容类型变更识别：无需数据重写的宽化型变更
const isPgCompatibleTypeChange = (currentType: string, newType: string): boolean => {
    const c = String(currentType || '').toLowerCase();
    const n = String(newType || '').toLowerCase();
    // varchar -> text 视为宽化
    if (c === 'character varying' && n === 'text') return true;
    // text -> character varying 非宽化（可能截断），不兼容
    return false;
};

/**
 * 数据库版本检查（按方言）
 *
 * 根据当前数据库类型检查版本是否符合最低要求：
 * - MySQL: >= 8.0
 * - PostgreSQL: >= 17
 * - SQLite: >= 3.50.0
 *
 * @throws {Error} 如果数据库版本不符合要求或无法获取版本信息
 */
const ensureDbVersion = async (): Promise<void> => {
    if (!sql) throw new Error('SQL 客户端未初始化');

    if (IS_MYSQL) {
        const r = await sql`SELECT VERSION() AS version`;
        if (!r || r.length === 0 || !r[0]?.version) {
            throw new Error('无法获取 MySQL 版本信息');
        }
        const version = r[0].version;
        const majorVersion = parseInt(String(version).split('.')[0], 10);
        if (!Number.isFinite(majorVersion) || majorVersion < DB_VERSION_REQUIREMENTS.MYSQL_MIN_MAJOR) {
            throw new Error(`此脚本仅支持 MySQL ${DB_VERSION_REQUIREMENTS.MYSQL_MIN_MAJOR}.0+，当前版本: ${version}`);
        }
        Logger.info(`MySQL 版本: ${version}`);
        return;
    }

    if (IS_PG) {
        const r = await sql`SELECT version() AS version`;
        if (!r || r.length === 0 || !r[0]?.version) {
            throw new Error('无法获取 PostgreSQL 版本信息');
        }
        const versionText = r[0].version;
        Logger.info(`PostgreSQL 版本: ${versionText}`);
        const m = /PostgreSQL\s+(\d+)/i.exec(versionText);
        const major = m ? parseInt(m[1], 10) : NaN;
        if (!Number.isFinite(major) || major < DB_VERSION_REQUIREMENTS.POSTGRES_MIN_MAJOR) {
            throw new Error(`此脚本要求 PostgreSQL >= ${DB_VERSION_REQUIREMENTS.POSTGRES_MIN_MAJOR}，当前: ${versionText}`);
        }
        return;
    }

    if (IS_SQLITE) {
        const r = await sql`SELECT sqlite_version() AS version`;
        if (!r || r.length === 0 || !r[0]?.version) {
            throw new Error('无法获取 SQLite 版本信息');
        }
        const version = r[0].version;
        Logger.info(`SQLite 版本: ${version}`);
        // 强制最低版本：SQLite ≥ 3.50.0
        const [maj, min, patch] = String(version)
            .split('.')
            .map((v) => parseInt(v, 10) || 0);
        const vnum = maj * 10000 + min * 100 + patch; // 3.50.0 -> 35000
        if (!Number.isFinite(vnum) || vnum < DB_VERSION_REQUIREMENTS.SQLITE_MIN_VERSION_NUM) {
            throw new Error(`此脚本要求 SQLite >= ${DB_VERSION_REQUIREMENTS.SQLITE_MIN_VERSION}，当前: ${version}`);
        }
        return;
    }
};

/**
 * 判断表是否存在（返回布尔值）
 *
 * @param tableName - 表名
 * @returns 表是否存在
 */
const tableExists = async (tableName: string): Promise<boolean> => {
    if (!sql) throw new Error('SQL 客户端未初始化');
    if (IS_MYSQL) {
        const res = await sql`SELECT COUNT(*) AS count FROM information_schema.TABLES WHERE TABLE_SCHEMA = ${Env.DB_NAME} AND TABLE_NAME = ${tableName}`;
        return (res[0]?.count || 0) > 0;
    }
    if (IS_PG) {
        const res = await sql`SELECT COUNT(*)::int AS count FROM information_schema.tables WHERE table_schema = 'public' AND table_name = ${tableName}`;
        return (res[0]?.count || 0) > 0;
    }
    if (IS_SQLITE) {
        const res = await sql`SELECT name FROM sqlite_master WHERE type='table' AND name = ${tableName}`;
        return res.length > 0;
    }
    return false;
};

/**
 * 获取表的现有列信息（按方言）
 *
 * 查询数据库元数据，获取表的所有列信息，包括：
 * - 列名
 * - 数据类型
 * - 字符最大长度
 * - 是否可为空
 * - 默认值
 * - 列注释（MySQL/PG）
 *
 * @param tableName - 表名
 * @returns 列信息对象，键为列名，值为列详情
 */
const getTableColumns = async (tableName: string): Promise<{ [key: string]: ColumnInfo }> => {
    const columns: { [key: string]: ColumnInfo } = {};
    if (IS_MYSQL) {
        const result = await sql`
            SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, IS_NULLABLE, COLUMN_DEFAULT, COLUMN_COMMENT, COLUMN_TYPE
            FROM information_schema.COLUMNS
            WHERE TABLE_SCHEMA = ${Env.DB_NAME} AND TABLE_NAME = ${tableName}
            ORDER BY ORDINAL_POSITION
        `;
        for (const row of result) {
            columns[row.COLUMN_NAME] = {
                type: row.DATA_TYPE,
                columnType: row.COLUMN_TYPE,
                length: row.CHARACTER_MAXIMUM_LENGTH,
                nullable: row.IS_NULLABLE === 'YES',
                defaultValue: row.COLUMN_DEFAULT,
                comment: row.COLUMN_COMMENT
            };
        }
    } else if (IS_PG) {
        const result = await sql`SELECT column_name, data_type, character_maximum_length, is_nullable, column_default
                        FROM information_schema.columns
                        WHERE table_schema = 'public' AND table_name = ${tableName}
                        ORDER BY ordinal_position`;
        // 获取列注释
        const comments = await sql`SELECT a.attname AS column_name, col_description(c.oid, a.attnum) AS column_comment
                          FROM pg_class c
                          JOIN pg_attribute a ON a.attrelid = c.oid
                          JOIN pg_namespace n ON n.oid = c.relnamespace
                          WHERE c.relkind = 'r' AND n.nspname = 'public' AND c.relname = ${tableName} AND a.attnum > 0`;
        const commentMap = {};
        for (const r of comments) commentMap[r.column_name] = r.column_comment;
        for (const row of result) {
            columns[row.column_name] = {
                type: row.data_type,
                columnType: row.data_type,
                length: row.character_maximum_length,
                nullable: String(row.is_nullable).toUpperCase() === 'YES',
                defaultValue: row.column_default,
                comment: commentMap[row.column_name] ?? null
            };
        }
    } else if (IS_SQLITE) {
        const result = await sql.unsafe(`PRAGMA table_info(${tableName})`);
        for (const row of result) {
            let baseType = String(row.type || '').toUpperCase();
            let length = null;
            const m = /^(\w+)\s*\((\d+)\)/.exec(baseType);
            if (m) {
                baseType = m[1];
                length = Number(m[2]);
            }
            columns[row.name] = {
                type: baseType.toLowerCase(),
                columnType: baseType.toLowerCase(),
                length: length,
                nullable: row.notnull === 0,
                defaultValue: row.dflt_value,
                comment: null
            };
        }
    }
    return columns;
};

/**
 * 获取表的现有索引信息（单列索引）
 *
 * @param tableName - 表名
 * @returns 索引信息对象，键为索引名，值为列名数组
 */
const getTableIndexes = async (tableName: string): Promise<IndexInfo> => {
    const indexes: IndexInfo = {};
    if (IS_MYSQL) {
        const result = await sql`
                        SELECT INDEX_NAME, COLUMN_NAME
                        FROM information_schema.STATISTICS
                        WHERE TABLE_SCHEMA = ${Env.DB_NAME}
                            AND TABLE_NAME = ${tableName}
                            AND INDEX_NAME != 'PRIMARY'
                        ORDER BY INDEX_NAME
                `;
        for (const row of result) {
            if (!indexes[row.INDEX_NAME]) indexes[row.INDEX_NAME] = [];
            indexes[row.INDEX_NAME].push(row.COLUMN_NAME);
        }
    } else if (IS_PG) {
        const result = await sql`SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'public' AND tablename = ${tableName}`;
        for (const row of result) {
            const m = /\(([^)]+)\)/.exec(row.indexdef);
            if (m) {
                const col = m[1].replace(/\"/g, '').replace(/"/g, '').trim();
                indexes[row.indexname] = [col];
            }
        }
    } else if (IS_SQLITE) {
        const list = await sql.unsafe(`PRAGMA index_list(${tableName})`);
        for (const idx of list) {
            const info = await sql.unsafe(`PRAGMA index_info(${idx.name})`);
            const cols = info.map((r) => r.name);
            if (cols.length === 1) indexes[idx.name] = cols;
        }
    }
    return indexes;
};

/**
 * 构建索引操作 SQL（统一使用在线策略）
 *
 * @param tableName - 表名
 * @param indexName - 索引名
 * @param fieldName - 字段名
 * @param action - 操作类型（create/drop）
 * @returns SQL 语句
 */
const buildIndexSQL = (tableName: string, indexName: string, fieldName: string, action: 'create' | 'drop'): string => {
    const tableQuoted = quoteIdentifier(tableName);
    const indexQuoted = quoteIdentifier(indexName);
    const fieldQuoted = quoteIdentifier(fieldName);

    if (IS_MYSQL) {
        const parts = [];
        if (action === 'create') {
            parts.push(`ADD INDEX ${indexQuoted} (${fieldQuoted})`);
        } else {
            parts.push(`DROP INDEX ${indexQuoted}`);
        }
        // 始终使用在线算法
        parts.push('ALGORITHM=INPLACE');
        parts.push('LOCK=NONE');
        return `ALTER TABLE ${tableQuoted} ${parts.join(', ')}`;
    }

    if (IS_PG) {
        if (action === 'create') {
            // 始终使用 CONCURRENTLY
            return `CREATE INDEX CONCURRENTLY IF NOT EXISTS ${indexQuoted} ON ${tableQuoted}(${fieldQuoted})`;
        }
        return `DROP INDEX CONCURRENTLY IF EXISTS ${indexQuoted}`;
    }

    // SQLite
    if (action === 'create') {
        return `CREATE INDEX IF NOT EXISTS ${indexQuoted} ON ${tableQuoted}(${fieldQuoted})`;
    }
    return `DROP INDEX IF EXISTS ${indexQuoted}`;
};

/**
 * 构建系统字段列定义
 *
 * @returns 系统字段的列定义数组
 */
const buildSystemColumnDefs = (): string[] => {
    if (IS_MYSQL) {
        return ['`id` BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT "主键ID"', '`created_at` BIGINT NOT NULL DEFAULT 0 COMMENT "创建时间"', '`updated_at` BIGINT NOT NULL DEFAULT 0 COMMENT "更新时间"', '`deleted_at` BIGINT NOT NULL DEFAULT 0 COMMENT "删除时间"', '`state` BIGINT NOT NULL DEFAULT 0 COMMENT "状态字段"'];
    }
    return ['"id" INTEGER PRIMARY KEY', '"created_at" INTEGER NOT NULL DEFAULT 0', '"updated_at" INTEGER NOT NULL DEFAULT 0', '"deleted_at" INTEGER NOT NULL DEFAULT 0', '"state" INTEGER NOT NULL DEFAULT 0'];
};

/**
 * 构建业务字段列定义
 *
 * @param fields - 字段定义对象
 * @returns 业务字段的列定义数组
 */
const buildBusinessColumnDefs = (fields: Record<string, string>): string[] => {
    const colDefs: string[] = [];

    for (const [fieldKey, fieldRule] of Object.entries(fields)) {
        const parsed = parseRule(fieldRule);
        const { name: fieldName, type: fieldType, max: fieldMax, default: fieldDefault } = parsed;
        const sqlType = ['string', 'array'].includes(fieldType) ? `${typeMapping[fieldType]}(${fieldMax})` : typeMapping[fieldType];
        const defaultSql = ['number', 'string', 'array'].includes(fieldType) ? (isType(fieldDefault, 'number') ? ` DEFAULT ${fieldDefault}` : ` DEFAULT '${fieldDefault}'`) : '';

        if (IS_MYSQL) {
            colDefs.push(`\`${fieldKey}\` ${sqlType} NOT NULL${defaultSql} COMMENT "${String(fieldName).replace(/"/g, '\\"')}"`);
        } else {
            colDefs.push(`"${fieldKey}" ${sqlType} NOT NULL${defaultSql}`);
        }
    }

    return colDefs;
};

/**
 * 为 PostgreSQL 表添加列注释
 *
 * @param tableName - 表名
 * @param fields - 字段定义对象
 */
const addPostgresComments = async (tableName: string, fields: Record<string, string>): Promise<void> => {
    // 系统字段注释
    const systemComments = [
        ['id', '主键ID'],
        ['created_at', '创建时间'],
        ['updated_at', '更新时间'],
        ['deleted_at', '删除时间'],
        ['state', '状态字段']
    ];

    for (const [name, comment] of systemComments) {
        const stmt = `COMMENT ON COLUMN "${tableName}"."${name}" IS '${comment}'`;
        if (IS_PLAN) {
            Logger.info(`[计划] ${stmt}`);
        } else {
            await sql.unsafe(stmt);
        }
    }

    // 业务字段注释
    for (const [fieldKey, fieldRule] of Object.entries(fields)) {
        const parsed = parseRule(fieldRule);
        const { name: fieldName } = parsed;
        const stmt = `COMMENT ON COLUMN "${tableName}"."${fieldKey}" IS '${fieldName}'`;
        if (IS_PLAN) {
            Logger.info(`[计划] ${stmt}`);
        } else {
            await sql.unsafe(stmt);
        }
    }
};

/**
 * 创建表的索引
 *
 * @param tableName - 表名
 * @param fields - 字段定义对象
 */
const createTableIndexes = async (tableName: string, fields: Record<string, string>): Promise<void> => {
    // 系统字段索引
    for (const sysField of SYSTEM_INDEX_FIELDS) {
        const stmt = buildIndexSQL(tableName, `idx_${sysField}`, sysField, 'create');
        if (IS_PLAN) {
            Logger.info(`[计划] ${stmt}`);
        } else {
            await sql.unsafe(stmt);
        }
    }

    // 业务字段索引
    for (const [fieldKey, fieldRule] of Object.entries(fields)) {
        const parsed = parseRule(fieldRule);
        if (parsed.index === 1) {
            const stmt = buildIndexSQL(tableName, `idx_${fieldKey}`, fieldKey, 'create');
            if (IS_PLAN) {
                Logger.info(`[计划] ${stmt}`);
            } else {
                await sql.unsafe(stmt);
            }
        }
    }
};

/**
 * 创建表（包含系统字段和业务字段）
 *
 * @param tableName - 表名
 * @param fields - 字段定义对象
 */
const createTable = async (tableName: string, fields: Record<string, string>): Promise<void> => {
    // 构建列定义
    const colDefs = [...buildSystemColumnDefs(), ...buildBusinessColumnDefs(fields)];

    // 生成 CREATE TABLE 语句
    const cols = colDefs.join(',\n            ');
    const tableQuoted = quoteIdentifier(tableName);
    const createSQL = IS_MYSQL ? `CREATE TABLE ${tableQuoted} (\n            ${cols}\n        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_as_cs` : `CREATE TABLE ${tableQuoted} (\n            ${cols}\n        )`;

    if (IS_PLAN) {
        Logger.info(`[计划] ${createSQL.replace(/\n+/g, ' ')}`);
    } else {
        await sql.unsafe(createSQL);
        Logger.info(`[新建表] ${tableName}`);
    }

    // PostgreSQL: 添加列注释
    if (IS_PG && !IS_PLAN) {
        await addPostgresComments(tableName, fields);
    } else if (IS_PG && IS_PLAN) {
        // 计划模式也要输出注释语句
        await addPostgresComments(tableName, fields);
    }

    // 创建索引
    await createTableIndexes(tableName, fields);
};

/**
 * 比较字段定义变化
 *
 * 对比现有列信息和新的字段规则，识别变化类型：
 * - 长度变化（string/array 类型）
 * - 注释变化（MySQL/PG）
 * - 数据类型变化
 * - 默认值变化
 *
 * @param existingColumn - 现有列信息
 * @param newRule - 新的字段规则字符串
 * @param colName - 列名（未使用，保留参数兼容性）
 * @returns 变化数组
 */
const compareFieldDefinition = (existingColumn: ColumnInfo, newRule: string, colName: string): FieldChange[] => {
    const parsed = parseRule(newRule);
    const { name: fieldName, type: fieldType, min: fieldMin, max: fieldMax, default: fieldDefault, index: fieldIndex, regex: fieldRegx } = parsed;
    const changes: FieldChange[] = [];

    // 检查长度变化（string和array类型） - SQLite 不比较长度
    if (!IS_SQLITE && (fieldType === 'string' || fieldType === 'array')) {
        if (existingColumn.length !== fieldMax) {
            changes.push({
                type: 'length',
                current: existingColumn.length,
                new: fieldMax
            });
        }
    }

    // 检查注释变化（MySQL/PG 支持列注释）
    if (!IS_SQLITE) {
        const currentComment = existingColumn.comment || '';
        if (currentComment !== fieldName) {
            changes.push({
                type: 'comment',
                current: currentComment,
                new: fieldName
            });
        }
    }

    // 检查数据类型变化（按方言）
    if (existingColumn.type.toLowerCase() !== typeMapping[fieldType].toLowerCase()) {
        changes.push({
            type: 'datatype',
            current: existingColumn.type,
            new: typeMapping[fieldType].toLowerCase()
        });
    }

    // 检查默认值变化（按照生成规则推导期望默认值）
    if (String(existingColumn.defaultValue) !== String(fieldDefault)) {
        changes.push({
            type: 'default',
            current: existingColumn.defaultValue,
            new: fieldDefault
        });
    }

    return changes;
};

/**
 * 生成字段 DDL 子句（不含 ALTER TABLE 前缀）
 *
 * @param fieldKey - 字段键名
 * @param fieldRule - 字段规则字符串
 * @param isAdd - 是否为添加字段（true）还是修改字段（false）
 * @returns DDL 子句
 */
const generateDDLClause = (fieldKey: string, fieldRule: string, isAdd: boolean = false): string => {
    const parsed = parseRule(fieldRule);
    const { name: fieldName, type: fieldType, min: fieldMin, max: fieldMax, default: fieldDefault, index: fieldIndex, regex: fieldRegx } = parsed;
    const sqlType = ['string', 'array'].includes(fieldType) ? `${typeMapping[fieldType]}(${fieldMax})` : typeMapping[fieldType];
    const defaultSql = ['number', 'string', 'array'].includes(fieldType) ? (isType(fieldDefault, 'number') ? ` DEFAULT ${fieldDefault}` : ` DEFAULT '${fieldDefault}'`) : '';
    if (IS_MYSQL) {
        return `${isAdd ? 'ADD COLUMN' : 'MODIFY COLUMN'} \`${fieldKey}\` ${sqlType} NOT NULL${defaultSql} COMMENT "${String(fieldName).replace(/"/g, '\\"')}"`;
    }
    if (IS_PG) {
        if (isAdd) return `ADD COLUMN IF NOT EXISTS "${fieldKey}" ${sqlType} NOT NULL${defaultSql}`;
        // PG 修改：类型与非空可分条执行，生成 TYPE 改变；非空另由上层统一控制
        return `ALTER COLUMN "${fieldKey}" TYPE ${sqlType}`;
    }
    // SQLite 仅支持 ADD COLUMN（>=3.50.0：支持 IF NOT EXISTS）
    if (isAdd) return `ADD COLUMN IF NOT EXISTS "${fieldKey}" ${sqlType} NOT NULL${defaultSql}`;
    return '';
};

/**
 * 安全执行 DDL 语句（MySQL 降级策略）
 *
 * 执行 DDL 时按以下顺序尝试：
 * 1. ALGORITHM=INSTANT (最快，无表锁)
 * 2. ALGORITHM=INPLACE (在线 DDL)
 * 3. 传统 DDL (可能需要表锁)
 *
 * @param stmt - DDL 语句
 * @returns 是否执行成功
 * @throws {Error} 如果所有尝试都失败
 */
const executeDDLSafely = async (stmt: string): Promise<boolean> => {
    try {
        await sql.unsafe(stmt);
        return true;
    } catch (error: any) {
        // MySQL 专用降级路径
        if (stmt.includes('ALGORITHM=INSTANT')) {
            const inplaceSql = stmt.replace(/ALGORITHM=INSTANT/g, 'ALGORITHM=INPLACE');
            try {
                await sql.unsafe(inplaceSql);
                return true;
            } catch (inplaceError) {
                // 最后尝试传统DDL：移除 ALGORITHM/LOCK 附加子句后执行
                const traditionSql = stmt
                    .replace(/,\s*ALGORITHM=INPLACE/g, '')
                    .replace(/,\s*ALGORITHM=INSTANT/g, '')
                    .replace(/,\s*LOCK=(NONE|SHARED|EXCLUSIVE)/g, '');
                await sql.unsafe(traditionSql);
                return true;
            }
        } else {
            throw error;
        }
    }
};

/**
 * SQLite 重建表迁移（简化版）
 *
 * SQLite 不支持修改列类型等操作，需要通过重建表实现：
 * 1. 创建临时表（新结构）
 * 2. 拷贝数据（仅公共列）
 * 3. 删除旧表
 * 4. 重命名临时表
 *
 * 注意：仅处理新增/修改字段，不处理复杂约束与复合索引
 *
 * @param tableName - 表名
 * @param fields - 字段定义对象
 */
const rebuildSqliteTable = async (tableName: string, fields: Record<string, string>): Promise<void> => {
    // 1. 读取现有列顺序
    const info = await sql.unsafe(`PRAGMA table_info(${tableName})`);
    const existingCols = info.map((r) => r.name);
    const targetCols = ['id', 'created_at', 'updated_at', 'deleted_at', 'state', ...Object.keys(fields)];
    const tmpTable = `${tableName}__tmp__${Date.now()}`;

    // 2. 创建新表（使用当前定义）
    await createTable(tmpTable, fields);

    // 3. 拷贝数据（按交集列）
    const commonCols = targetCols.filter((c) => existingCols.includes(c));
    if (commonCols.length > 0) {
        const colsSql = commonCols.map((c) => `"${c}"`).join(', ');
        await sql.unsafe(`INSERT INTO "${tmpTable}" (${colsSql}) SELECT ${colsSql} FROM "${tableName}"`);
    }

    // 4. 删除旧表并重命名
    await sql.unsafe(`DROP TABLE "${tableName}"`);
    await sql.unsafe(`ALTER TABLE "${tmpTable}" RENAME TO "${tableName}"`);
};

/**
 * 将表结构计划应用到数据库（执行 DDL/索引/注释等）
 *
 * 根据数据库方言和计划内容，执行相应的 DDL 操作：
 * - SQLite: 新增字段直接 ALTER，其他操作需要重建表
 * - MySQL: 尝试在线 DDL（INSTANT/INPLACE）
 * - PostgreSQL: 直接 ALTER
 *
 * @param tableName - 表名
 * @param fields - 字段定义对象
 * @param plan - 表结构变更计划
 */
const applyTablePlan = async (tableName: string, fields: Record<string, string>, plan: TablePlan): Promise<void> => {
    if (!plan || !plan.changed) return;

    // SQLite: 仅支持部分 ALTER；需要时走重建
    if (IS_SQLITE) {
        if (plan.modifyClauses.length > 0 || plan.defaultClauses.length > 0) {
            if (IS_PLAN) Logger.info(`[计划] 重建表 ${tableName} 以应用列修改/默认值变化`);
            else await rebuildSqliteTable(tableName, fields);
        } else {
            for (const c of plan.addClauses) {
                const stmt = `ALTER TABLE "${tableName}" ${c}`;
                if (IS_PLAN) Logger.info(`[计划] ${stmt}`);
                else await sql.unsafe(stmt);
            }
        }
    } else {
        const clauses = [...plan.addClauses, ...plan.modifyClauses];
        if (clauses.length > 0) {
            const suffix = IS_MYSQL ? ', ALGORITHM=INSTANT, LOCK=NONE' : '';
            const stmt = IS_MYSQL ? `ALTER TABLE \`${tableName}\` ${clauses.join(', ')}${suffix}` : `ALTER TABLE "${tableName}" ${clauses.join(', ')}`;
            if (IS_PLAN) Logger.info(`[计划] ${stmt}`);
            else if (IS_MYSQL) await executeDDLSafely(stmt);
            else await sql.unsafe(stmt);
        }
    }

    // 默认值专用 ALTER（SQLite 不支持）
    if (plan.defaultClauses.length > 0) {
        if (IS_SQLITE) {
            Logger.warn(`SQLite 不支持修改默认值，表 ${tableName} 的默认值变更已跳过`);
        } else {
            const suffix = IS_MYSQL ? ', ALGORITHM=INSTANT, LOCK=NONE' : '';
            const stmt = IS_MYSQL ? `ALTER TABLE \`${tableName}\` ${plan.defaultClauses.join(', ')}${suffix}` : `ALTER TABLE "${tableName}" ${plan.defaultClauses.join(', ')}`;
            if (IS_PLAN) Logger.info(`[计划] ${stmt}`);
            else if (IS_MYSQL) await executeDDLSafely(stmt);
            else await sql.unsafe(stmt);
        }
    }

    // 索引操作
    for (const act of plan.indexActions) {
        const stmt = buildIndexSQL(tableName, act.indexName, act.fieldName, act.action);
        if (IS_PLAN) {
            Logger.info(`[计划] ${stmt}`);
        } else {
            try {
                await sql.unsafe(stmt);
                if (act.action === 'create') {
                    Logger.info(`[索引变化] 新建索引 ${tableName}.${act.indexName} (${act.fieldName})`);
                } else {
                    Logger.info(`[索引变化] 删除索引 ${tableName}.${act.indexName} (${act.fieldName})`);
                }
            } catch (error: any) {
                Logger.error(`${act.action === 'create' ? '创建' : '删除'}索引失败: ${error.message}`);
                Logger.error(`表名: ${tableName}, 索引名: ${act.indexName}, 字段: ${act.fieldName}`);
                throw error;
            }
        }
    }

    // PG 列注释
    if (IS_PG && plan.commentActions && plan.commentActions.length > 0) {
        for (const stmt of plan.commentActions) {
            if (IS_PLAN) Logger.info(`[计划] ${stmt}`);
            else await sql.unsafe(stmt);
        }
    }

    // 计数
    globalCount.modifiedTables++;
};

/**
 * 同步表结构（对比和应用变更）
 *
 * 主要逻辑：
 * 1. 获取表的现有列和索引信息
 * 2. 对比每个字段的定义变化
 * 3. 生成 DDL 变更计划
 * 4. 处理索引的增删
 * 5. 应用变更计划
 *
 * 安全策略：
 * - 禁止字段类型变更（除 string<->array）
 * - 跳过危险的长度收缩
 * - 使用在线 DDL（MySQL/PG）
 *
 * @param tableName - 表名
 * @param fields - 字段定义对象
 * @returns 表结构变更计划
 */
const modifyTable = async (tableName: string, fields: Record<string, string>): Promise<TablePlan> => {
    const existingColumns = await getTableColumns(tableName);
    const existingIndexes = await getTableIndexes(tableName);
    let changed = false;

    const addClauses = [];
    const modifyClauses = [];
    const defaultClauses = [];
    const indexActions = [];

    for (const [fieldKey, fieldRule] of Object.entries(fields)) {
        if (existingColumns[fieldKey]) {
            const comparison = compareFieldDefinition(existingColumns[fieldKey], fieldRule, fieldKey);
            if (comparison.length > 0) {
                for (const c of comparison) {
                    // 使用统一的日志格式函数
                    logFieldChange(tableName, fieldKey, c.type, c.current, c.new);
                    // 全量计数：全局累加
                    if (c.type === 'datatype') globalCount.typeChanges++;
                    else if (c.type === 'length') globalCount.maxChanges++;
                    else if (c.type === 'default') globalCount.defaultChanges++;
                    else if (c.type === 'comment') globalCount.nameChanges++;
                }
                const parsed = parseRule(fieldRule);
                const { name: fieldName, type: fieldType, min: fieldMin, max: fieldMax, default: fieldDefault, index: fieldIndex, regex: fieldRegx } = parsed;
                if ((fieldType === 'string' || fieldType === 'array') && existingColumns[fieldKey].length) {
                    if (existingColumns[fieldKey].length > fieldMax) {
                        Logger.warn(`[跳过危险变更] ${tableName}.${fieldKey} 长度收缩 ${existingColumns[fieldKey].length} -> ${fieldMax} 已被跳过（设置 SYNC_DISALLOW_SHRINK=0 可放开）`);
                    }
                }
                const hasTypeChange = comparison.some((c) => c.type === 'datatype');
                const hasLengthChange = comparison.some((c) => c.type === 'length');
                const onlyDefaultChanged = comparison.every((c) => c.type === 'default');
                const defaultChanged = comparison.some((c) => c.type === 'default');

                // 严格限制：除 string/array 互转外，禁止任何字段类型变更；一旦发现，立即终止同步
                // 说明：string 与 array 在各方言下映射同为 VARCHAR/character varying/TEXT，compare 不会将其视为类型变更
                if (hasTypeChange) {
                    const currentSqlType = String(existingColumns[fieldKey].type || '').toLowerCase();
                    const newSqlType = String(typeMapping[fieldType] || '').toLowerCase();
                    // 明确抛错，阻止后续任何 DDL 应用，提供详细上下文
                    const errorMsg = [`禁止字段类型变更: ${tableName}.${fieldKey}`, `当前类型: ${currentSqlType}`, `目标类型: ${newSqlType}`, `说明: 仅允许 string<->array 互相切换，其他类型变更需要手动处理`].join('\n');
                    throw new Error(errorMsg);
                }

                // 默认值变化处理：
                if (defaultChanged) {
                    const v = fieldType === 'number' ? fieldDefault : `'${fieldDefault}'`;
                    if (IS_PG) {
                        defaultClauses.push(`ALTER COLUMN "${fieldKey}" SET DEFAULT ${v}`);
                    } else if (IS_MYSQL && onlyDefaultChanged) {
                        // MySQL 的 TEXT/BLOB 不允许 DEFAULT，跳过 text 类型
                        if (fieldType !== 'text') {
                            defaultClauses.push(`ALTER COLUMN \`${fieldKey}\` SET DEFAULT ${v}`);
                        }
                    }
                }

                // 若不仅仅是默认值变化，继续生成修改子句
                if (!onlyDefaultChanged) {
                    let skipModify = false;
                    if (hasLengthChange && (fieldType === 'string' || fieldType === 'array') && existingColumns[fieldKey].length) {
                        const oldLen = existingColumns[fieldKey].length;
                        const isShrink = oldLen > fieldMax;
                        if (isShrink) skipModify = true;
                    }
                    if (hasTypeChange) {
                        if (IS_PG && isPgCompatibleTypeChange(existingColumns[fieldKey].type, typeMapping[fieldType].toLowerCase())) {
                            Logger.info(`[PG兼容类型变更] ${tableName}.${fieldKey} ${existingColumns[fieldKey].type} -> ${typeMapping[fieldType].toLowerCase()} 允许执行`);
                        }
                    }
                    if (!skipModify) modifyClauses.push(generateDDLClause(fieldKey, fieldRule, false));
                }
                changed = true;
            }
        } else {
            const parsed = parseRule(fieldRule);
            const { name: fieldName, type: fieldType, min: fieldMin, max: fieldMax, default: fieldDefault, index: fieldIndex, regex: fieldRegx } = parsed;
            const lenPart = fieldType === 'string' || fieldType === 'array' ? ` 长度:${parseInt(fieldMax)}` : '';
            Logger.info(`[新增字段] ${tableName}.${fieldKey} 类型:${fieldType}${lenPart} 默认:${fieldDefault ?? 'NULL'}`);
            addClauses.push(generateDDLClause(fieldKey, fieldRule, true));
            changed = true;
            globalCount.addFields++;
        }
    }

    for (const sysField of ['created_at', 'updated_at', 'state']) {
        const idxName = `idx_${sysField}`;
        if (!existingIndexes[idxName]) {
            indexActions.push({ action: 'create', indexName: idxName, fieldName: sysField });
            changed = true;
            globalCount.indexCreate++;
        }
    }
    for (const [fieldKey, fieldRule] of Object.entries(fields)) {
        const parsed = parseRule(fieldRule);
        const { name: fieldName, type: fieldType, min: fieldMin, max: fieldMax, default: fieldDefault, index: fieldIndex, regex: fieldRegx } = parsed;
        const indexName = `idx_${fieldKey}`;
        if (fieldIndex === 1 && !existingIndexes[indexName]) {
            indexActions.push({ action: 'create', indexName, fieldName: fieldKey });
            changed = true;
            globalCount.indexCreate++;
        } else if (!(fieldIndex === 1) && existingIndexes[indexName] && existingIndexes[indexName].length === 1) {
            indexActions.push({ action: 'drop', indexName, fieldName: fieldKey });
            changed = true;
            globalCount.indexDrop++;
        }
    }

    const commentActions = [];
    if (IS_PG) {
        for (const [fieldKey, fieldRule] of Object.entries(fields)) {
            if (existingColumns[fieldKey]) {
                const parsed = parseRule(fieldRule);
                const { name: fieldName } = parsed;
                const curr = existingColumns[fieldKey].comment || '';
                const want = fieldName && fieldName !== 'null' ? String(fieldName) : '';
                if (want !== curr) {
                    commentActions.push(`COMMENT ON COLUMN "${tableName}"."${fieldKey}" IS ${want ? `'${want}'` : 'NULL'}`);
                    changed = true;
                }
            }
        }
    }
    // 仅当存在实际动作时才认为有变更（避免仅日志的收缩跳过被计为修改）
    changed = addClauses.length > 0 || modifyClauses.length > 0 || defaultClauses.length > 0 || indexActions.length > 0 || commentActions.length > 0;
    const plan = { changed, addClauses, modifyClauses, defaultClauses, indexActions, commentActions };
    // 将计划应用（包含 --plan 情况下仅输出）
    if (plan.changed) {
        await applyTablePlan(tableName, fields, plan);
    }
    return plan;
};

// 主同步函数
export const SyncDb = async (): Promise<void> => {
    try {
        // 记录开始时间
        perfStats.startTime = Date.now();

        Logger.info('开始数据库表结构同步...');

        // 重置全局统计，避免多次调用累加
        for (const k of Object.keys(globalCount)) {
            if (typeof globalCount[k] === 'number') globalCount[k] = 0;
        }

        // 验证表定义文件
        markPhase('validation');
        if (!(await checkTable())) {
            throw new Error('表定义验证失败');
        }
        Logger.info(`✓ 表定义验证完成，耗时: ${getPhaseTime('validation')}ms`);

        // 建立数据库连接并检查版本（按方言）
        markPhase('connection');
        sql = await createSqlClient({ max: 1 });
        await ensureDbVersion();
        Logger.info(`✓ 数据库连接建立，耗时: ${getPhaseTime('connection')}ms`);

        // 扫描并处理表文件
        markPhase('scan');
        const tablesGlob = new Bun.Glob('*.json');
        const directories: Array<{ path: string; isCore: boolean; addonName?: string }> = [
            { path: __dirtables, isCore: true },
            { path: getProjectDir('tables'), isCore: false }
        ];

        // 添加所有 addon 的 tables 目录
        const addons = scanAddons();
        for (const addon of addons) {
            if (hasAddonDir(addon, 'tables')) {
                directories.push({
                    path: getAddonDir(addon, 'tables'),
                    isCore: false,
                    addonName: addon
                });
            }
        }

        // 统计表文件总数
        let totalTables = 0;
        for (const dirConfig of directories) {
            for await (const file of tablesGlob.scan({ cwd: dirConfig.path, absolute: true, onlyFiles: true })) {
                const fileName = path.basename(file, '.json');
                if (!fileName.startsWith('_')) {
                    totalTables++;
                }
            }
        }
        Logger.info(`✓ 扫描完成，发现 ${totalTables} 个表定义文件，耗时: ${getPhaseTime('scan')}ms`);

        // 处理表文件
        markPhase('process');
        let processedCount = 0;

        for (const dirConfig of directories) {
            const { path: dir, isCore, addonName } = dirConfig;
            const dirType = isCore ? '内核' : addonName ? `组件[${addonName}]` : '项目';

            for await (const file of tablesGlob.scan({ cwd: dir, absolute: true, onlyFiles: true })) {
                const fileName = path.basename(file, '.json');

                // 跳过以下划线开头的文件（这些是公共字段规则，不是表定义）
                if (fileName.startsWith('_')) {
                    Logger.info(`跳过非表定义文件: ${fileName}.json`);
                    continue;
                }

                // 确定表名前缀：
                // - 核心表：sys_ 前缀
                // - addon 表：{addonName}_ 前缀
                // - 项目表：无前缀
                let tableName = toSnakeTableName(fileName);
                if (isCore) {
                    tableName = `sys_${tableName}`;
                } else if (addonName) {
                    tableName = `${addonName}_${tableName}`;
                }

                processedCount++;
                Logger.info(`[${processedCount}/${totalTables}] 处理表: ${tableName} (${dirType})`);

                const tableDefinition = await Bun.file(file).json();
                const existsTable = await tableExists(tableName);

                if (existsTable) {
                    await modifyTable(tableName, tableDefinition);
                } else {
                    await createTable(tableName, tableDefinition);
                    globalCount.createdTables++;
                }
                globalCount.processedTables++;
            }
        }

        Logger.info(`✓ 表处理完成，耗时: ${getPhaseTime('process')}ms`);

        // 显示统计信息（扩展维度）
        const totalTime = Date.now() - perfStats.startTime;
        Logger.info('\n=== 同步统计信息 ===');
        Logger.info(`总耗时: ${totalTime}ms`);
        Logger.info(`处理表总数: ${globalCount.processedTables}`);
        Logger.info(`创建表: ${globalCount.createdTables}`);
        Logger.info(`修改表: ${globalCount.modifiedTables}`);
        Logger.info(`字段新增: ${globalCount.addFields}`);
        Logger.info(`字段名称变更: ${globalCount.nameChanges}`);
        Logger.info(`字段类型变更: ${globalCount.typeChanges}`);
        Logger.info(`字段最小值变更: ${globalCount.minChanges}`);
        Logger.info(`字段最大值变更: ${globalCount.maxChanges}`);
        Logger.info(`字段默认值变更: ${globalCount.defaultChanges}`);
        Logger.info(`索引新增: ${globalCount.indexCreate}`);
        Logger.info(`索引删除: ${globalCount.indexDrop}`);

        if (globalCount.processedTables === 0) {
            Logger.warn('没有找到任何表定义文件');
        }

        // 保持单一职责：此处不再触发开发管理员同步
    } catch (error: any) {
        Logger.error(`数据库同步失败: ${error.message}`);
        Logger.error(`错误详情: ${error.stack}`);
        if (error.code) {
            Logger.error(`错误代码: ${error.code}`);
        }
        if (error.errno) {
            Logger.error(`错误编号: ${error.errno}`);
        }
        process.exit(1);
    } finally {
        if (sql) {
            try {
                await sql.close();
            } catch (error: any) {
                Logger.warn('关闭数据库连接时出错:', error.message);
            }
        }
    }
};

// 如果直接运行此脚本（Bun 支持 import.meta.main）
if (import.meta.main) {
    SyncDb().catch((error) => {
        console.error('❌ 数据库同步失败:', error);
        process.exit(1);
    });
}
